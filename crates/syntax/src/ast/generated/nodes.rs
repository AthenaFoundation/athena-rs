//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(
    non_snake_case,
    dead_code,
    unused_imports,
    clippy::match_single_binding,
    clippy::needless_return
)]
use crate::{
    ast::{self, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
impl Name {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}
impl NameRef {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}
impl Literal {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetaIdent {
    pub(crate) syntax: SyntaxNode,
}
impl MetaIdent {
    pub fn single_quote_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['\''])
    }
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Unit {
    pub(crate) syntax: SyntaxNode,
}
impl Unit {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypedParam {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for TypedParam {}
impl TypedParam {
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OpAnnotatedParam {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for OpAnnotatedParam {}
impl ast::HasNameRef for OpAnnotatedParam {}
impl OpAnnotatedParam {
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn OP_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![OP])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Wildcard {
    pub(crate) syntax: SyntaxNode,
}
impl Wildcard {
    pub fn underscore_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![_])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixBinding {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixBinding {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VarSort {
    pub(crate) syntax: SyntaxNode,
}
impl VarSort {
    pub fn single_quote_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['\''])
    }
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentSort {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasNameRef for IdentSort {}
impl IdentSort {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CompoundSort {
    pub(crate) syntax: SyntaxNode,
}
impl CompoundSort {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn sorts(&self) -> AstChildren<Sort> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
impl SourceFile {
    pub fn stmts(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DatatypeStmt {
    pub(crate) syntax: SyntaxNode,
}
impl DatatypeStmt {
    pub fn datatype_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![datatype])
    }
    pub fn structure_def(&self) -> Option<StructureDef> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructureStmt {
    pub(crate) syntax: SyntaxNode,
}
impl StructureStmt {
    pub fn structure_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![structure])
    }
    pub fn structure_def(&self) -> Option<StructureDef> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DatatypesStmt {
    pub(crate) syntax: SyntaxNode,
}
impl DatatypesStmt {
    pub fn datatypes_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![datatypes])
    }
    pub fn structure_defs(&self) -> AstChildren<StructureDef> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructuresStmt {
    pub(crate) syntax: SyntaxNode,
}
impl StructuresStmt {
    pub fn structures_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![structures])
    }
    pub fn structure_defs(&self) -> AstChildren<StructureDef> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructureNameDef {
    pub(crate) syntax: SyntaxNode,
}
impl StructureNameDef {
    pub fn sort_decl(&self) -> Option<SortDecl> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstantConstructor {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for ConstantConstructor {}
impl ConstantConstructor {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CompoundConstructor {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for CompoundConstructor {}
impl CompoundConstructor {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn maybe_tagged_field_sort(&self) -> Option<MaybeTaggedFieldSort> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LimitedCompoundSort {
    pub(crate) syntax: SyntaxNode,
}
impl LimitedCompoundSort {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn ident_sort(&self) -> Option<IdentSort> {
        support::child(&self.syntax)
    }
    pub fn limited_sorts(&self) -> AstChildren<LimitedSort> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MaybeTaggedFieldSort {
    pub(crate) syntax: SyntaxNode,
}
impl MaybeTaggedFieldSort {
    pub fn tag(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn limited_sort(&self) -> Option<LimitedSort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructureDef {
    pub(crate) syntax: SyntaxNode,
}
impl StructureDef {
    pub fn structure_name_def(&self) -> Option<StructureNameDef> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn structure_constructors(&self) -> AstChildren<StructureConstructor> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixDefineDir {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasDefineName for InfixDefineDir {}
impl ast::HasDefineBody for InfixDefineDir {}
impl InfixDefineDir {
    pub fn private_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![private])
    }
    pub fn define_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![define])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleDir {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for ModuleDir {}
impl ModuleDir {
    pub fn module_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![module])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn stmts(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExtendModuleDir {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for ExtendModuleDir {}
impl ExtendModuleDir {
    pub fn extend_module_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![extend - module])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn stmts(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssertClosedDir {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AssertClosedDir {}
impl AssertClosedDir {
    pub fn assert_star_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assert *])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DomainDir {
    pub(crate) syntax: SyntaxNode,
}
impl DomainDir {
    pub fn domain_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![domain])
    }
    pub fn sort_decl(&self) -> Option<SortDecl> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DomainsDir {
    pub(crate) syntax: SyntaxNode,
}
impl DomainsDir {
    pub fn domains_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![domains])
    }
    pub fn sort_decls(&self) -> AstChildren<SortDecl> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoadDir {
    pub(crate) syntax: SyntaxNode,
}
impl LoadDir {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn load_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![load])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OpenDir {
    pub(crate) syntax: SyntaxNode,
}
impl OpenDir {
    pub fn open_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![open])
    }
    pub fn name_refs(&self) -> AstChildren<NameRef> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssociativityDir {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasNameRef for AssociativityDir {}
impl AssociativityDir {
    pub fn left_assoc_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![left - assoc])
    }
    pub fn right_assoc_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![right - assoc])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SetPrecedenceDir {
    pub(crate) syntax: SyntaxNode,
}
impl SetPrecedenceDir {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn set_precedence_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![set - precedence])
    }
    pub fn name_refs(&self) -> AstChildren<NameRef> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentSortDecl {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for IdentSortDecl {}
impl IdentSortDecl {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CompoundSortDecl {
    pub(crate) syntax: SyntaxNode,
}
impl CompoundSortDecl {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn ident_sort_decls(&self) -> AstChildren<IdentSortDecl> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixConstantDeclare {
    pub(crate) syntax: SyntaxNode,
}
impl InfixConstantDeclare {
    pub fn declare_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![declare])
    }
    pub fn names(&self) -> AstChildren<Name> {
        support::children(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixConstantDeclare {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixConstantDeclare {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn declare_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![declare])
    }
    pub fn prefix_declare_symbols(&self) -> Option<PrefixDeclareSymbols> {
        support::child(&self.syntax)
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixDeclareDir {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixDeclareDir {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn declare_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![declare])
    }
    pub fn prefix_declare_symbols(&self) -> Option<PrefixDeclareSymbols> {
        support::child(&self.syntax)
    }
    pub fn prefix_sort_vars_decl(&self) -> Option<PrefixSortVarsDecl> {
        support::child(&self.syntax)
    }
    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![->])
    }
    pub fn sorts(&self) -> AstChildren<Sort> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
    pub fn prefix_declare_attrs(&self) -> Option<PrefixDeclareAttrs> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixSortVarsDecl {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixSortVarsDecl {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn ident_sort_decls(&self) -> AstChildren<IdentSortDecl> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixDeclareAttrs {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixDeclareAttrs {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn declare_attrs(&self) -> AstChildren<DeclareAttr> {
        support::children(&self.syntax)
    }
    pub fn input_transform_decl(&self) -> Option<InputTransformDecl> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixSingleSymbol {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for PrefixSingleSymbol {}
impl PrefixSingleSymbol {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixMultiSymbols {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixMultiSymbols {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn names(&self) -> AstChildren<Name> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DeclareAttr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for DeclareAttr {}
impl DeclareAttr {
    pub fn left_assoc_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![left - assoc])
    }
    pub fn right_assoc_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![right - assoc])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InputTransformDecl {
    pub(crate) syntax: SyntaxNode,
}
impl InputTransformDecl {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixDeclareDir {
    pub(crate) syntax: SyntaxNode,
}
impl InfixDeclareDir {
    pub fn declare_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![declare])
    }
    pub fn names(&self) -> AstChildren<Name> {
        support::children(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort_vars_decl(&self) -> Option<SortVarsDecl> {
        support::child(&self.syntax)
    }
    pub fn func_sorts(&self) -> Option<FuncSorts> {
        support::child(&self.syntax)
    }
    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![->])
    }
    pub fn return_sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
    pub fn declare_attrs(&self) -> Option<DeclareAttrs> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SortVarsDecl {
    pub(crate) syntax: SyntaxNode,
}
impl SortVarsDecl {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn ident_sort_decls(&self) -> AstChildren<IdentSortDecl> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FuncSorts {
    pub(crate) syntax: SyntaxNode,
}
impl FuncSorts {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn sorts(&self) -> AstChildren<Sort> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DeclareAttrs {
    pub(crate) syntax: SyntaxNode,
}
impl DeclareAttrs {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn declare_attrs(&self) -> AstChildren<DeclareAttr> {
        support::children(&self.syntax)
    }
    pub fn input_transform_decl(&self) -> Option<InputTransformDecl> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixDefine {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasDefineName for PrefixDefine {}
impl ast::HasDefineBody for PrefixDefine {}
impl PrefixDefine {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn define_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![define])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixDefineBlocks {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixDefineBlocks {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn define_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![define])
    }
    pub fn prefix_define_blocks(&self) -> AstChildren<PrefixDefineBlock> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixDefineBlock {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasDefineBody for PrefixDefineBlock {}
impl PrefixDefineBlock {
    pub fn define_proc(&self) -> Option<DefineProc> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefineNamedPattern {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for DefineNamedPattern {}
impl DefineNamedPattern {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![as])
    }
    pub fn list_pat(&self) -> Option<ListPat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefineProc {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for DefineProc {}
impl DefineProc {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn args(&self) -> AstChildren<MaybeWildcardTypedParam> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListPat {
    pub(crate) syntax: SyntaxNode,
}
impl ListPat {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn pats(&self) -> AstChildren<Pat> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixAssertDir {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for InfixAssertDir {}
impl InfixAssertDir {
    pub fn assert_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assert])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixAssertDir {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for PrefixAssertDir {}
impl PrefixAssertDir {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn assert_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assert])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixRuleDir {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for InfixRuleDir {}
impl InfixRuleDir {
    pub fn primitive_method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![primitive - method])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn maybe_wildcard_typed_params(&self) -> AstChildren<MaybeWildcardTypedParam> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixRuleDir {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for PrefixRuleDir {}
impl PrefixRuleDir {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn primitive_method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![primitive - method])
    }
    pub fn maybe_wildcard_typed_params(&self) -> AstChildren<MaybeWildcardTypedParam> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExpandInputDir {
    pub(crate) syntax: SyntaxNode,
}
impl ExpandInputDir {
    pub fn expand_input_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![expand - input])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn expander(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefineSortDir {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for DefineSortDir {}
impl DefineSortDir {
    pub fn define_sort_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![define - sort])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PhrasePair {
    pub(crate) syntax: SyntaxNode,
}
impl PhrasePair {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OverloadSingle {
    pub(crate) syntax: SyntaxNode,
}
impl OverloadSingle {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn overload_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![overload])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OverloadMulti {
    pub(crate) syntax: SyntaxNode,
}
impl OverloadMulti {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn overload_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![overload])
    }
    pub fn phrase_pairs(&self) -> AstChildren<PhrasePair> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasNameRef for IdentExpr {}
impl IdentExpr {
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LiteralExpr {
    pub fn literal(&self) -> Option<Literal> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnitExpr {
    pub(crate) syntax: SyntaxNode,
}
impl UnitExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TermVarExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TermVarExpr {
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![?])
    }
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CheckExpr {
    pub fn check_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![check])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn check_arms(&self) -> AstChildren<CheckArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LambdaExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LambdaExpr {
    pub fn lambda_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![lambda])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn maybe_wildcard_typed_params(&self) -> AstChildren<MaybeWildcardTypedParam> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ApplicationExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ApplicationExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ListExpr {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MethodExpr {
    pub fn method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![method])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn maybe_wildcard_typed_params(&self) -> AstChildren<MaybeWildcardTypedParam> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LetExpr {
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn let_parts(&self) -> AstChildren<LetPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetRecExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LetRecExpr {
    pub fn letrec_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![letrec])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn let_rec_parts(&self) -> AstChildren<LetRecPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TryExpr {
    pub fn try_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![try])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn try_arms(&self) -> AstChildren<TryArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CellExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CellExpr {
    pub fn cell_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![cell])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl SetExpr {
    pub fn set_bang_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![set!])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefExpr {
    pub(crate) syntax: SyntaxNode,
}
impl RefExpr {
    pub fn ref_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ref])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub(crate) syntax: SyntaxNode,
}
impl WhileExpr {
    pub fn while_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![while])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MakeVectorExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MakeVectorExpr {
    pub fn make_vector_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![make - vector])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VectorSubExpr {
    pub(crate) syntax: SyntaxNode,
}
impl VectorSubExpr {
    pub fn vector_sub_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![vector - sub])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VectorSetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl VectorSetExpr {
    pub fn vector_set_bang_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![vector - set!])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SeqExpr {
    pub(crate) syntax: SyntaxNode,
}
impl SeqExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn seq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![seq])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AndExpr {
    pub(crate) syntax: SyntaxNode,
}
impl AndExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn ampamp_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![&&])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OrExpr {
    pub(crate) syntax: SyntaxNode,
}
impl OrExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pipepipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![||])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MapExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MapExpr {
    pub fn pipe_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["|{"])
    }
    pub fn map_bindings(&self) -> AstChildren<MapBinding> {
        support::children(&self.syntax)
    }
    pub fn curly_pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}|"])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WildcardExpr {
    pub(crate) syntax: SyntaxNode,
}
impl WildcardExpr {
    pub fn underscore_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![_])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixCheckExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixCheckExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn check_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![check])
    }
    pub fn check_clauses(&self) -> AstChildren<CheckClause> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetaIdentExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MetaIdentExpr {
    pub fn meta_ident(&self) -> Option<MetaIdent> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckArm {
    pub(crate) syntax: SyntaxNode,
}
impl CheckArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckClause {
    pub(crate) syntax: SyntaxNode,
}
impl CheckClause {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixLetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixLetExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn prefix_bindings(&self) -> AstChildren<PrefixBinding> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetPart {
    pub(crate) syntax: SyntaxNode,
}
impl LetPart {
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixLetRecExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixLetRecExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn letrec_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![letrec])
    }
    pub fn prefix_bindings(&self) -> AstChildren<PrefixBinding> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetRecPart {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for LetRecPart {}
impl LetRecPart {
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixMatchExpr {
    pub(crate) syntax: SyntaxNode,
}
impl InfixMatchExpr {
    pub fn match_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![match])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn arms(&self) -> AstChildren<MatchArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixMatchExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixMatchExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn match_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![match])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn clauses(&self) -> AstChildren<MatchClause> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub(crate) syntax: SyntaxNode,
}
impl MatchArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchClause {
    pub(crate) syntax: SyntaxNode,
}
impl MatchClause {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryArm {
    pub(crate) syntax: SyntaxNode,
}
impl TryArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixTryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixTryExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn try_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![try])
    }
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MapBinding {
    pub(crate) syntax: SyntaxNode,
}
impl MapBinding {
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodCallDed {
    pub(crate) syntax: SyntaxNode,
}
impl MethodCallDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn apply_method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![apply - method])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BangMethodCallDed {
    pub(crate) syntax: SyntaxNode,
}
impl BangMethodCallDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn bang_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![!])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssumeDed {
    pub(crate) syntax: SyntaxNode,
}
impl AssumeDed {
    pub fn assume_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assume])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedAssumeDed {
    pub(crate) syntax: SyntaxNode,
}
impl NamedAssumeDed {
    pub fn assume_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assume])
    }
    pub fn assume_parts(&self) -> AstChildren<AssumePart> {
        support::children(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ProofByContraDed {
    pub(crate) syntax: SyntaxNode,
}
impl ProofByContraDed {
    pub fn suppose_absurd_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![suppose - absurd])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GeneralizeOverDed {
    pub(crate) syntax: SyntaxNode,
}
impl GeneralizeOverDed {
    pub fn generalize_over_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![generalize - over])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PickAnyDed {
    pub(crate) syntax: SyntaxNode,
}
impl PickAnyDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pick_any_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pick - any])
    }
    pub fn maybe_typed_params(&self) -> AstChildren<MaybeTypedParam> {
        support::children(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WithWitnessDed {
    pub(crate) syntax: SyntaxNode,
}
impl WithWitnessDed {
    pub fn with_witness_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![with - witness])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PickWitnessDed {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for PickWitnessDed {}
impl PickWitnessDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pick_witness_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pick - witness])
    }
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PickWitnessesDed {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for PickWitnessesDed {}
impl PickWitnessesDed {
    pub fn pick_witnesses_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pick - witnesses])
    }
    pub fn names(&self) -> AstChildren<Name> {
        support::children(&self.syntax)
    }
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InductDed {
    pub(crate) syntax: SyntaxNode,
}
impl InductDed {
    pub fn by_induction_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![by - induction])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn restricted_match_deds(&self) -> AstChildren<RestrictedMatchDed> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CasesDed {
    pub(crate) syntax: SyntaxNode,
}
impl CasesDed {
    pub fn datatype_cases_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![datatype - cases])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn on_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![on])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn restricted_match_deds(&self) -> AstChildren<RestrictedMatchDed> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConcludeDed {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for ConcludeDed {}
impl ConcludeDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn conclude_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![conclude])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferBlockDed {
    pub(crate) syntax: SyntaxNode,
}
impl InferBlockDed {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn begin_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![begin])
    }
    pub fn maybe_named_inferences(&self) -> AstChildren<MaybeNamedInference> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![end])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SeqDed {
    pub(crate) syntax: SyntaxNode,
}
impl SeqDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn dseq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dseq])
    }
    pub fn deds(&self) -> AstChildren<Ded> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssumePart {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AssumePart {}
impl AssumePart {
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixNamedAssumeDed {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for PrefixNamedAssumeDed {}
impl PrefixNamedAssumeDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn assume_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assume])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixSingleAssumeDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixSingleAssumeDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn assume_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assume])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixAssumeLetDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixAssumeLetDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn assume_let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assume - let])
    }
    pub fn prefix_binding(&self) -> Option<PrefixBinding> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestrictedMatchDed {
    pub(crate) syntax: SyntaxNode,
}
impl RestrictedMatchDed {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckDedClause {
    pub(crate) syntax: SyntaxNode,
}
impl CheckDedClause {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixCheckDed {
    pub(crate) syntax: SyntaxNode,
}
impl InfixCheckDed {
    pub fn check_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![check])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn arms(&self) -> AstChildren<CheckDedArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixCheckDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixCheckDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn dcheck_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dcheck])
    }
    pub fn check_ded_clauses(&self) -> AstChildren<CheckDedClause> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckDedArm {
    pub(crate) syntax: SyntaxNode,
}
impl CheckDedArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixMatchDed {
    pub(crate) syntax: SyntaxNode,
}
impl InfixMatchDed {
    pub fn match_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![match])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn arms(&self) -> AstChildren<MatchDedArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixMatchDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixMatchDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn dmatch_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dmatch])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn clauses(&self) -> AstChildren<MatchDedClause> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchDedArm {
    pub(crate) syntax: SyntaxNode,
}
impl MatchDedArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchDedClause {
    pub(crate) syntax: SyntaxNode,
}
impl MatchDedClause {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixLetDed {
    pub(crate) syntax: SyntaxNode,
}
impl InfixLetDed {
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn let_parts(&self) -> AstChildren<LetPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixLetRecDed {
    pub(crate) syntax: SyntaxNode,
}
impl InfixLetRecDed {
    pub fn letrec_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![letrec])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn let_rec_parts(&self) -> AstChildren<LetRecPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixLetDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixLetDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn dlet_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dlet])
    }
    pub fn prefix_bindings(&self) -> AstChildren<PrefixBinding> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixLetRecDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixLetRecDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn dletrec_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dletrec])
    }
    pub fn prefix_bindings(&self) -> AstChildren<PrefixBinding> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixTryDed {
    pub(crate) syntax: SyntaxNode,
}
impl InfixTryDed {
    pub fn try_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![try])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn try_ded_arms(&self) -> AstChildren<TryDedArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixTryDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixTryDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn dtry_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dtry])
    }
    pub fn deds(&self) -> AstChildren<Ded> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryDedArm {
    pub(crate) syntax: SyntaxNode,
}
impl TryDedArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MaybeNamedInference {
    pub(crate) syntax: SyntaxNode,
}
impl MaybeNamedInference {
    pub fn maybe_wildcard_op_annotated_param(&self) -> Option<MaybeWildcardOpAnnotatedParam> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn infer_or_expr(&self) -> Option<InferOrExpr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MaybeWildcardOpAnnotatedParam {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for MaybeWildcardOpAnnotatedParam {}
impl MaybeWildcardOpAnnotatedParam {
    pub fn underscore_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![_])
    }
    pub fn op_annotated_param(&self) -> Option<OpAnnotatedParam> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferFrom {
    pub(crate) syntax: SyntaxNode,
}
impl InferFrom {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn from_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![from])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferBy {
    pub(crate) syntax: SyntaxNode,
}
impl InferBy {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn by_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![by])
    }
    pub fn by_expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn on_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![on])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ByDed {
    pub(crate) syntax: SyntaxNode,
}
impl ByDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn by_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![by])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPat {
    pub(crate) syntax: SyntaxNode,
}
impl IdentPat {
    pub fn maybe_wildcard_typed_param(&self) -> Option<MaybeWildcardTypedParam> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VarPat {
    pub(crate) syntax: SyntaxNode,
}
impl VarPat {
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![?])
    }
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetaIdentPat {
    pub(crate) syntax: SyntaxNode,
}
impl MetaIdentPat {
    pub fn meta_ident(&self) -> Option<MetaIdent> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralPat {
    pub(crate) syntax: SyntaxNode,
}
impl LiteralPat {
    pub fn literal(&self) -> Option<Literal> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnitPat {
    pub(crate) syntax: SyntaxNode,
}
impl UnitPat {
    pub fn unit(&self) -> Option<Unit> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedPat {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for NamedPat {}
impl NamedPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn bind_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![bind])
    }
    pub fn as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![as])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ValOfPat {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasNameRef for ValOfPat {}
impl ValOfPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn val_of_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![val - of])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListOfPat {
    pub(crate) syntax: SyntaxNode,
}
impl ListOfPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn list_of_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![list - of])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SplitPat {
    pub(crate) syntax: SyntaxNode,
}
impl SplitPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn split_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![split])
    }
    pub fn first(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn second(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn rest(&self) -> AstChildren<Pat> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CompoundPat {
    pub(crate) syntax: SyntaxNode,
}
impl CompoundPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pats(&self) -> AstChildren<Pat> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WherePat {
    pub(crate) syntax: SyntaxNode,
}
impl WherePat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn where_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![where])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SomeThingPat {
    pub(crate) syntax: SyntaxNode,
}
impl SomeThingPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn some_thing(&self) -> Option<SomeThing> {
        support::child(&self.syntax)
    }
    pub fn ident_pat(&self) -> Option<IdentPat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OrPat {
    pub(crate) syntax: SyntaxNode,
}
impl OrPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pipepipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![||])
    }
    pub fn pats(&self) -> AstChildren<Pat> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SomeThing {
    pub(crate) syntax: SyntaxNode,
}
impl SomeThing {
    pub fn some_var_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - var])
    }
    pub fn some_sent_con_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - sent - con])
    }
    pub fn some_quant_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - quant])
    }
    pub fn some_term_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - term])
    }
    pub fn some_atom_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - atom])
    }
    pub fn some_sentence_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - sentence])
    }
    pub fn some_list_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - list])
    }
    pub fn some_cell_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - cell])
    }
    pub fn some_vector_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - vector])
    }
    pub fn some_proc_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - proc])
    }
    pub fn some_method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - method])
    }
    pub fn some_symbol_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - symbol])
    }
    pub fn some_table_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - table])
    }
    pub fn some_map_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - map])
    }
    pub fn some_sub_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - sub])
    }
    pub fn some_char_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - char])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MaybeTypedParam {
    Name(Name),
    TypedParam(TypedParam),
    OpAnnotatedParam(OpAnnotatedParam),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Sort {
    VarSort(VarSort),
    IdentSort(IdentSort),
    CompoundSort(CompoundSort),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MaybeWildcardTypedParam {
    MaybeTypedParam(MaybeTypedParam),
    Wildcard(Wildcard),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Pat {
    IdentPat(IdentPat),
    VarPat(VarPat),
    MetaIdentPat(MetaIdentPat),
    LiteralPat(LiteralPat),
    UnitPat(UnitPat),
    NamedPat(NamedPat),
    ValOfPat(ValOfPat),
    ListOfPat(ListOfPat),
    SplitPat(SplitPat),
    ListPat(ListPat),
    CompoundPat(CompoundPat),
    WherePat(WherePat),
    SomeThingPat(SomeThingPat),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Phrase {
    Expr(Expr),
    Ded(Ded),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    Dir(Dir),
    Phrase(Phrase),
    DatatypeStmt(DatatypeStmt),
    StructureStmt(StructureStmt),
    DatatypesStmt(DatatypesStmt),
    StructuresStmt(StructuresStmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Dir {
    ModuleDir(ModuleDir),
    DomainDir(DomainDir),
    DomainsDir(DomainsDir),
    DefineDir(DefineDir),
    LoadDir(LoadDir),
    AssertDir(AssertDir),
    AssertClosedDir(AssertClosedDir),
    DeclareDir(DeclareDir),
    ConstantDeclareDir(ConstantDeclareDir),
    ExtendModuleDir(ExtendModuleDir),
    OpenDir(OpenDir),
    AssociativityDir(AssociativityDir),
    SetPrecedenceDir(SetPrecedenceDir),
    OverloadDir(OverloadDir),
    RuleDir(RuleDir),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SortDecl {
    IdentSortDecl(IdentSortDecl),
    CompoundSortDecl(CompoundSortDecl),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum StructureConstructor {
    ConstantConstructor(ConstantConstructor),
    CompoundConstructor(CompoundConstructor),
}
impl ast::HasName for StructureConstructor {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LimitedSort {
    IdentSort(IdentSort),
    LimitedCompoundSort(LimitedCompoundSort),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MetaDefinition {
    Definition(Definition),
    Domain(Domain),
    FunctionSymbol(FunctionSymbol),
    Assertion(Assertion),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Definition {
    InfixDefineDir(InfixDefineDir),
    PrefixDefineDir(PrefixDefineDir),
}
impl ast::HasDefineBody for Definition {}
impl ast::HasDefineName for Definition {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Domain {
    DomainDir(DomainDir),
    DomainsDir(DomainsDir),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FunctionSymbol {
    DeclareDir(DeclareDir),
    ConstantDeclareDir(ConstantDeclareDir),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Assertion {
    AssertDir(AssertDir),
    AssertClosedDir(AssertClosedDir),
}
impl ast::HasName for Assertion {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PrefixDefineDir {
    PrefixDefine(PrefixDefine),
    PrefixDefineBlocks(PrefixDefineBlocks),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Structure {
    StructureStmt(StructureStmt),
    StructuresStmt(StructuresStmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Datatype {
    DatatypeStmt(DatatypeStmt),
    DatatypesStmt(DatatypesStmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Module {
    ModuleDir(ModuleDir),
    ExtendModuleDir(ExtendModuleDir),
}
impl ast::HasName for Module {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssertDir {
    InfixAssertDir(InfixAssertDir),
    PrefixAssertDir(PrefixAssertDir),
}
impl ast::HasName for AssertDir {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DeclareDir {
    PrefixDeclareDir(PrefixDeclareDir),
    InfixDeclareDir(InfixDeclareDir),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ConstantDeclareDir {
    InfixConstantDeclare(InfixConstantDeclare),
    PrefixConstantDeclare(PrefixConstantDeclare),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DefineDir {
    InfixDefineDir(InfixDefineDir),
    PrefixDefineDir(PrefixDefineDir),
}
impl ast::HasDefineBody for DefineDir {}
impl ast::HasDefineName for DefineDir {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum OverloadDir {
    OverloadSingle(OverloadSingle),
    OverloadMulti(OverloadMulti),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RuleDir {
    InfixRuleDir(InfixRuleDir),
    PrefixRuleDir(PrefixRuleDir),
}
impl ast::HasName for RuleDir {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PrefixDeclareSymbols {
    PrefixSingleSymbol(PrefixSingleSymbol),
    PrefixMultiSymbols(PrefixMultiSymbols),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    IdentExpr(IdentExpr),
    LiteralExpr(LiteralExpr),
    UnitExpr(UnitExpr),
    TermVarExpr(TermVarExpr),
    MetaIdent(MetaIdent),
    CheckExpr(CheckExpr),
    LambdaExpr(LambdaExpr),
    ApplicationExpr(ApplicationExpr),
    ListExpr(ListExpr),
    MethodExpr(MethodExpr),
    LetExpr(LetExpr),
    LetRecExpr(LetRecExpr),
    MatchExpr(MatchExpr),
    TryExpr(TryExpr),
    CellExpr(CellExpr),
    SetExpr(SetExpr),
    RefExpr(RefExpr),
    WhileExpr(WhileExpr),
    MakeVectorExpr(MakeVectorExpr),
    VectorSubExpr(VectorSubExpr),
    VectorSetExpr(VectorSetExpr),
    SeqExpr(SeqExpr),
    AndExpr(AndExpr),
    OrExpr(OrExpr),
    MapExpr(MapExpr),
    WildcardExpr(WildcardExpr),
    PrefixCheckExpr(PrefixCheckExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DefineName {
    Name(Name),
    DefineNamedPattern(DefineNamedPattern),
    DefineProc(DefineProc),
    ListPat(ListPat),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Ded {
    MethodCallDed(MethodCallDed),
    BangMethodCallDed(BangMethodCallDed),
    AssumeDed(AssumeDed),
    NamedAssumeDed(NamedAssumeDed),
    ProofByContraDed(ProofByContraDed),
    GeneralizeOverDed(GeneralizeOverDed),
    PickAnyDed(PickAnyDed),
    WithWitnessDed(WithWitnessDed),
    PickWitnessDed(PickWitnessDed),
    PickWitnessesDed(PickWitnessesDed),
    InductDed(InductDed),
    CasesDed(CasesDed),
    CheckDed(CheckDed),
    MatchDed(MatchDed),
    LetDed(LetDed),
    LetRecDed(LetRecDed),
    TryDed(TryDed),
    ConcludeDed(ConcludeDed),
    InferBlockDed(InferBlockDed),
    PrefixAssumeDed(PrefixAssumeDed),
    SeqDed(SeqDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MatchExpr {
    InfixMatchExpr(InfixMatchExpr),
    PrefixMatchExpr(PrefixMatchExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum CheckDed {
    InfixCheckDed(InfixCheckDed),
    PrefixCheckDed(PrefixCheckDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MatchDed {
    InfixMatchDed(InfixMatchDed),
    PrefixMatchDed(PrefixMatchDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LetDed {
    InfixLetDed(InfixLetDed),
    PrefixLetDed(PrefixLetDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LetRecDed {
    InfixLetRecDed(InfixLetRecDed),
    PrefixLetRecDed(PrefixLetRecDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TryDed {
    InfixTryDed(InfixTryDed),
    PrefixTryDed(PrefixTryDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PrefixAssumeDed {
    PrefixNamedAssumeDed(PrefixNamedAssumeDed),
    PrefixSingleAssumeDed(PrefixSingleAssumeDed),
    PrefixAssumeLetDed(PrefixAssumeLetDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum InferOrExpr {
    Inference(Inference),
    Expr(Expr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Inference {
    InferFrom(InferFrom),
    InferBy(InferBy),
    Ded(Ded),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasDefineBody {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasDefineBody for AnyHasDefineBody {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasDefineName {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasDefineName for AnyHasDefineName {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasName {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AnyHasName {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasNameRef {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasNameRef for AnyHasNameRef {}
impl AstNode for Name {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAME
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NameRef {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAME_REF
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Literal {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MetaIdent {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == META_IDENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Unit {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNIT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TypedParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPED_PARAM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OpAnnotatedParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OP_ANNOTATED_PARAM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Wildcard {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WILDCARD
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixBinding {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_BINDING
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VarSort {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VAR_SORT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentSort {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_SORT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CompoundSort {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COMPOUND_SORT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SourceFile {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOURCE_FILE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DatatypeStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DATATYPE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructureStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCTURE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DatatypesStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DATATYPES_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructuresStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCTURES_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructureNameDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCTURE_NAME_DEF
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ConstantConstructor {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONSTANT_CONSTRUCTOR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CompoundConstructor {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COMPOUND_CONSTRUCTOR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LimitedCompoundSort {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIMITED_COMPOUND_SORT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MaybeTaggedFieldSort {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAYBE_TAGGED_FIELD_SORT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructureDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCTURE_DEF
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixDefineDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_DEFINE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ModuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MODULE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExtendModuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXTEND_MODULE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssertClosedDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSERT_CLOSED_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DomainDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DOMAIN_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DomainsDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DOMAINS_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LoadDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LOAD_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OpenDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OPEN_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssociativityDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSOCIATIVITY_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SetPrecedenceDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SET_PRECEDENCE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentSortDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_SORT_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CompoundSortDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COMPOUND_SORT_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixConstantDeclare {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_CONSTANT_DECLARE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixConstantDeclare {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_CONSTANT_DECLARE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixDeclareDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_DECLARE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixSortVarsDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_SORT_VARS_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixDeclareAttrs {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_DECLARE_ATTRS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixSingleSymbol {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_SINGLE_SYMBOL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixMultiSymbols {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_MULTI_SYMBOLS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DeclareAttr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DECLARE_ATTR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InputTransformDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INPUT_TRANSFORM_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixDeclareDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_DECLARE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SortVarsDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SORT_VARS_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FuncSorts {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNC_SORTS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DeclareAttrs {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DECLARE_ATTRS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixDefine {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_DEFINE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixDefineBlocks {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_DEFINE_BLOCKS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixDefineBlock {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_DEFINE_BLOCK
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefineNamedPattern {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEFINE_NAMED_PATTERN
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefineProc {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEFINE_PROC
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixAssertDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_ASSERT_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixAssertDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_ASSERT_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixRuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_RULE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixRuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_RULE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExpandInputDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPAND_INPUT_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefineSortDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEFINE_SORT_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PhrasePair {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PHRASE_PAIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OverloadSingle {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OVERLOAD_SINGLE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OverloadMulti {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OVERLOAD_MULTI
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LiteralExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UnitExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNIT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TermVarExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TERM_VAR_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LambdaExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LAMBDA_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ApplicationExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == APPLICATION_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MethodExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == METHOD_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetRecExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_REC_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CellExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CELL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SetExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SET_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RefExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == REF_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WhileExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WHILE_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MakeVectorExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAKE_VECTOR_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VectorSubExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VECTOR_SUB_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VectorSetExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VECTOR_SET_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SeqExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SEQ_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AndExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == AND_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OrExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OR_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MapExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAP_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WildcardExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WILDCARD_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixCheckExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_CHECK_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MetaIdentExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == META_IDENT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckClause {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_CLAUSE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixLetExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_LET_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetPart {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_PART
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixLetRecExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_LET_REC_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetRecPart {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_REC_PART
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixMatchExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_MATCH_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixMatchExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_MATCH_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MatchArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MatchClause {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_CLAUSE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TryArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRY_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixTryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_TRY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MapBinding {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAP_BINDING
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MethodCallDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == METHOD_CALL_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BangMethodCallDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BANG_METHOD_CALL_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssumeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSUME_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NamedAssumeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMED_ASSUME_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ProofByContraDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PROOF_BY_CONTRA_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for GeneralizeOverDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GENERALIZE_OVER_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PickAnyDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PICK_ANY_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WithWitnessDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WITH_WITNESS_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PickWitnessDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PICK_WITNESS_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PickWitnessesDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PICK_WITNESSES_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InductDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INDUCT_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CasesDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CASES_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ConcludeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONCLUDE_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InferBlockDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFER_BLOCK_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SeqDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SEQ_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssumePart {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSUME_PART
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixNamedAssumeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_NAMED_ASSUME_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixSingleAssumeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_SINGLE_ASSUME_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixAssumeLetDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_ASSUME_LET_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RestrictedMatchDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RESTRICTED_MATCH_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckDedClause {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_DED_CLAUSE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixCheckDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_CHECK_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixCheckDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_CHECK_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckDedArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_DED_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixMatchDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_MATCH_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixMatchDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_MATCH_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MatchDedArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_DED_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MatchDedClause {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_DED_CLAUSE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixLetDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_LET_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixLetRecDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_LET_REC_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixLetDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_LET_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixLetRecDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_LET_REC_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixTryDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_TRY_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixTryDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_TRY_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TryDedArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRY_DED_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MaybeNamedInference {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAYBE_NAMED_INFERENCE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MaybeWildcardOpAnnotatedParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAYBE_WILDCARD_OP_ANNOTATED_PARAM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InferFrom {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFER_FROM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InferBy {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFER_BY
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ByDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BY_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VarPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VAR_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MetaIdentPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == META_IDENT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LiteralPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UnitPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNIT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NamedPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMED_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ValOfPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VAL_OF_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListOfPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_OF_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SplitPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SPLIT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CompoundPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COMPOUND_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WherePat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WHERE_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SomeThingPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOME_THING_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OrPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OR_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SomeThing {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOME_THING
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl From<Name> for MaybeTypedParam {
    fn from(node: Name) -> MaybeTypedParam {
        MaybeTypedParam::Name(node)
    }
}
impl From<TypedParam> for MaybeTypedParam {
    fn from(node: TypedParam) -> MaybeTypedParam {
        MaybeTypedParam::TypedParam(node)
    }
}
impl From<OpAnnotatedParam> for MaybeTypedParam {
    fn from(node: OpAnnotatedParam) -> MaybeTypedParam {
        MaybeTypedParam::OpAnnotatedParam(node)
    }
}
impl AstNode for MaybeTypedParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, NAME | TYPED_PARAM | OP_ANNOTATED_PARAM)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAME => Self::Name(Name { syntax }),
            TYPED_PARAM => Self::TypedParam(TypedParam { syntax }),
            OP_ANNOTATED_PARAM => Self::OpAnnotatedParam(OpAnnotatedParam { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MaybeTypedParam::Name(it) => it.syntax(),
            MaybeTypedParam::TypedParam(it) => it.syntax(),
            MaybeTypedParam::OpAnnotatedParam(it) => it.syntax(),
        }
    }
}
impl From<VarSort> for Sort {
    fn from(node: VarSort) -> Sort {
        Sort::VarSort(node)
    }
}
impl From<IdentSort> for Sort {
    fn from(node: IdentSort) -> Sort {
        Sort::IdentSort(node)
    }
}
impl From<CompoundSort> for Sort {
    fn from(node: CompoundSort) -> Sort {
        Sort::CompoundSort(node)
    }
}
impl AstNode for Sort {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, VAR_SORT | IDENT_SORT | COMPOUND_SORT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            VAR_SORT => Self::VarSort(VarSort { syntax }),
            IDENT_SORT => Self::IdentSort(IdentSort { syntax }),
            COMPOUND_SORT => Self::CompoundSort(CompoundSort { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Sort::VarSort(it) => it.syntax(),
            Sort::IdentSort(it) => it.syntax(),
            Sort::CompoundSort(it) => it.syntax(),
        }
    }
}
impl From<MaybeTypedParam> for MaybeWildcardTypedParam {
    fn from(node: MaybeTypedParam) -> MaybeWildcardTypedParam {
        MaybeWildcardTypedParam::MaybeTypedParam(node)
    }
}
impl From<Wildcard> for MaybeWildcardTypedParam {
    fn from(node: Wildcard) -> MaybeWildcardTypedParam {
        MaybeWildcardTypedParam::Wildcard(node)
    }
}
impl AstNode for MaybeWildcardTypedParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, WILDCARD) || MaybeTypedParam::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            WILDCARD => Self::Wildcard(Wildcard { syntax }),
            other => {
                if false {
                    return None;
                } else if MaybeTypedParam::can_cast(other) {
                    return MaybeTypedParam::cast(syntax).map(Self::MaybeTypedParam);
                } else {
                    return None;
                }
            }
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MaybeWildcardTypedParam::MaybeTypedParam(it) => it.syntax(),
            MaybeWildcardTypedParam::Wildcard(it) => it.syntax(),
        }
    }
}
impl From<IdentPat> for Pat {
    fn from(node: IdentPat) -> Pat {
        Pat::IdentPat(node)
    }
}
impl From<VarPat> for Pat {
    fn from(node: VarPat) -> Pat {
        Pat::VarPat(node)
    }
}
impl From<MetaIdentPat> for Pat {
    fn from(node: MetaIdentPat) -> Pat {
        Pat::MetaIdentPat(node)
    }
}
impl From<LiteralPat> for Pat {
    fn from(node: LiteralPat) -> Pat {
        Pat::LiteralPat(node)
    }
}
impl From<UnitPat> for Pat {
    fn from(node: UnitPat) -> Pat {
        Pat::UnitPat(node)
    }
}
impl From<NamedPat> for Pat {
    fn from(node: NamedPat) -> Pat {
        Pat::NamedPat(node)
    }
}
impl From<ValOfPat> for Pat {
    fn from(node: ValOfPat) -> Pat {
        Pat::ValOfPat(node)
    }
}
impl From<ListOfPat> for Pat {
    fn from(node: ListOfPat) -> Pat {
        Pat::ListOfPat(node)
    }
}
impl From<SplitPat> for Pat {
    fn from(node: SplitPat) -> Pat {
        Pat::SplitPat(node)
    }
}
impl From<ListPat> for Pat {
    fn from(node: ListPat) -> Pat {
        Pat::ListPat(node)
    }
}
impl From<CompoundPat> for Pat {
    fn from(node: CompoundPat) -> Pat {
        Pat::CompoundPat(node)
    }
}
impl From<WherePat> for Pat {
    fn from(node: WherePat) -> Pat {
        Pat::WherePat(node)
    }
}
impl From<SomeThingPat> for Pat {
    fn from(node: SomeThingPat) -> Pat {
        Pat::SomeThingPat(node)
    }
}
impl AstNode for Pat {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            IDENT_PAT
                | VAR_PAT
                | META_IDENT_PAT
                | LITERAL_PAT
                | UNIT_PAT
                | NAMED_PAT
                | VAL_OF_PAT
                | LIST_OF_PAT
                | SPLIT_PAT
                | LIST_PAT
                | COMPOUND_PAT
                | WHERE_PAT
                | SOME_THING_PAT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_PAT => Self::IdentPat(IdentPat { syntax }),
            VAR_PAT => Self::VarPat(VarPat { syntax }),
            META_IDENT_PAT => Self::MetaIdentPat(MetaIdentPat { syntax }),
            LITERAL_PAT => Self::LiteralPat(LiteralPat { syntax }),
            UNIT_PAT => Self::UnitPat(UnitPat { syntax }),
            NAMED_PAT => Self::NamedPat(NamedPat { syntax }),
            VAL_OF_PAT => Self::ValOfPat(ValOfPat { syntax }),
            LIST_OF_PAT => Self::ListOfPat(ListOfPat { syntax }),
            SPLIT_PAT => Self::SplitPat(SplitPat { syntax }),
            LIST_PAT => Self::ListPat(ListPat { syntax }),
            COMPOUND_PAT => Self::CompoundPat(CompoundPat { syntax }),
            WHERE_PAT => Self::WherePat(WherePat { syntax }),
            SOME_THING_PAT => Self::SomeThingPat(SomeThingPat { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Pat::IdentPat(it) => it.syntax(),
            Pat::VarPat(it) => it.syntax(),
            Pat::MetaIdentPat(it) => it.syntax(),
            Pat::LiteralPat(it) => it.syntax(),
            Pat::UnitPat(it) => it.syntax(),
            Pat::NamedPat(it) => it.syntax(),
            Pat::ValOfPat(it) => it.syntax(),
            Pat::ListOfPat(it) => it.syntax(),
            Pat::SplitPat(it) => it.syntax(),
            Pat::ListPat(it) => it.syntax(),
            Pat::CompoundPat(it) => it.syntax(),
            Pat::WherePat(it) => it.syntax(),
            Pat::SomeThingPat(it) => it.syntax(),
        }
    }
}
impl From<Expr> for Phrase {
    fn from(node: Expr) -> Phrase {
        Phrase::Expr(node)
    }
}
impl From<Ded> for Phrase {
    fn from(node: Ded) -> Phrase {
        Phrase::Ded(node)
    }
}
impl AstNode for Phrase {
    fn can_cast(kind: SyntaxKind) -> bool {
        Expr::can_cast(kind) || Ded::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            other => {
                if false {
                    return None;
                } else if Expr::can_cast(other) {
                    return Expr::cast(syntax).map(Self::Expr);
                } else if Ded::can_cast(other) {
                    return Ded::cast(syntax).map(Self::Ded);
                } else {
                    return None;
                }
            }
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Phrase::Expr(it) => it.syntax(),
            Phrase::Ded(it) => it.syntax(),
        }
    }
}
impl From<Dir> for Stmt {
    fn from(node: Dir) -> Stmt {
        Stmt::Dir(node)
    }
}
impl From<Phrase> for Stmt {
    fn from(node: Phrase) -> Stmt {
        Stmt::Phrase(node)
    }
}
impl From<DatatypeStmt> for Stmt {
    fn from(node: DatatypeStmt) -> Stmt {
        Stmt::DatatypeStmt(node)
    }
}
impl From<StructureStmt> for Stmt {
    fn from(node: StructureStmt) -> Stmt {
        Stmt::StructureStmt(node)
    }
}
impl From<DatatypesStmt> for Stmt {
    fn from(node: DatatypesStmt) -> Stmt {
        Stmt::DatatypesStmt(node)
    }
}
impl From<StructuresStmt> for Stmt {
    fn from(node: StructuresStmt) -> Stmt {
        Stmt::StructuresStmt(node)
    }
}
impl AstNode for Stmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            DATATYPE_STMT | STRUCTURE_STMT | DATATYPES_STMT | STRUCTURES_STMT
        ) || Dir::can_cast(kind)
            || Phrase::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            DATATYPE_STMT => Self::DatatypeStmt(DatatypeStmt { syntax }),
            STRUCTURE_STMT => Self::StructureStmt(StructureStmt { syntax }),
            DATATYPES_STMT => Self::DatatypesStmt(DatatypesStmt { syntax }),
            STRUCTURES_STMT => Self::StructuresStmt(StructuresStmt { syntax }),
            other => {
                if false {
                    return None;
                } else if Dir::can_cast(other) {
                    return Dir::cast(syntax).map(Self::Dir);
                } else if Phrase::can_cast(other) {
                    return Phrase::cast(syntax).map(Self::Phrase);
                } else {
                    return None;
                }
            }
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Stmt::Dir(it) => it.syntax(),
            Stmt::Phrase(it) => it.syntax(),
            Stmt::DatatypeStmt(it) => it.syntax(),
            Stmt::StructureStmt(it) => it.syntax(),
            Stmt::DatatypesStmt(it) => it.syntax(),
            Stmt::StructuresStmt(it) => it.syntax(),
        }
    }
}
impl From<ModuleDir> for Dir {
    fn from(node: ModuleDir) -> Dir {
        Dir::ModuleDir(node)
    }
}
impl From<DomainDir> for Dir {
    fn from(node: DomainDir) -> Dir {
        Dir::DomainDir(node)
    }
}
impl From<DomainsDir> for Dir {
    fn from(node: DomainsDir) -> Dir {
        Dir::DomainsDir(node)
    }
}
impl From<DefineDir> for Dir {
    fn from(node: DefineDir) -> Dir {
        Dir::DefineDir(node)
    }
}
impl From<LoadDir> for Dir {
    fn from(node: LoadDir) -> Dir {
        Dir::LoadDir(node)
    }
}
impl From<AssertDir> for Dir {
    fn from(node: AssertDir) -> Dir {
        Dir::AssertDir(node)
    }
}
impl From<AssertClosedDir> for Dir {
    fn from(node: AssertClosedDir) -> Dir {
        Dir::AssertClosedDir(node)
    }
}
impl From<DeclareDir> for Dir {
    fn from(node: DeclareDir) -> Dir {
        Dir::DeclareDir(node)
    }
}
impl From<ConstantDeclareDir> for Dir {
    fn from(node: ConstantDeclareDir) -> Dir {
        Dir::ConstantDeclareDir(node)
    }
}
impl From<ExtendModuleDir> for Dir {
    fn from(node: ExtendModuleDir) -> Dir {
        Dir::ExtendModuleDir(node)
    }
}
impl From<OpenDir> for Dir {
    fn from(node: OpenDir) -> Dir {
        Dir::OpenDir(node)
    }
}
impl From<AssociativityDir> for Dir {
    fn from(node: AssociativityDir) -> Dir {
        Dir::AssociativityDir(node)
    }
}
impl From<SetPrecedenceDir> for Dir {
    fn from(node: SetPrecedenceDir) -> Dir {
        Dir::SetPrecedenceDir(node)
    }
}
impl From<OverloadDir> for Dir {
    fn from(node: OverloadDir) -> Dir {
        Dir::OverloadDir(node)
    }
}
impl From<RuleDir> for Dir {
    fn from(node: RuleDir) -> Dir {
        Dir::RuleDir(node)
    }
}
impl AstNode for Dir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            MODULE_DIR
                | DOMAIN_DIR
                | DOMAINS_DIR
                | LOAD_DIR
                | ASSERT_CLOSED_DIR
                | EXTEND_MODULE_DIR
                | OPEN_DIR
                | ASSOCIATIVITY_DIR
                | SET_PRECEDENCE_DIR
        ) || DefineDir::can_cast(kind)
            || AssertDir::can_cast(kind)
            || DeclareDir::can_cast(kind)
            || ConstantDeclareDir::can_cast(kind)
            || OverloadDir::can_cast(kind)
            || RuleDir::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            MODULE_DIR => Self::ModuleDir(ModuleDir { syntax }),
            DOMAIN_DIR => Self::DomainDir(DomainDir { syntax }),
            DOMAINS_DIR => Self::DomainsDir(DomainsDir { syntax }),
            LOAD_DIR => Self::LoadDir(LoadDir { syntax }),
            ASSERT_CLOSED_DIR => Self::AssertClosedDir(AssertClosedDir { syntax }),
            EXTEND_MODULE_DIR => Self::ExtendModuleDir(ExtendModuleDir { syntax }),
            OPEN_DIR => Self::OpenDir(OpenDir { syntax }),
            ASSOCIATIVITY_DIR => Self::AssociativityDir(AssociativityDir { syntax }),
            SET_PRECEDENCE_DIR => Self::SetPrecedenceDir(SetPrecedenceDir { syntax }),
            other => {
                if false {
                    return None;
                } else if DefineDir::can_cast(other) {
                    return DefineDir::cast(syntax).map(Self::DefineDir);
                } else if AssertDir::can_cast(other) {
                    return AssertDir::cast(syntax).map(Self::AssertDir);
                } else if DeclareDir::can_cast(other) {
                    return DeclareDir::cast(syntax).map(Self::DeclareDir);
                } else if ConstantDeclareDir::can_cast(other) {
                    return ConstantDeclareDir::cast(syntax).map(Self::ConstantDeclareDir);
                } else if OverloadDir::can_cast(other) {
                    return OverloadDir::cast(syntax).map(Self::OverloadDir);
                } else if RuleDir::can_cast(other) {
                    return RuleDir::cast(syntax).map(Self::RuleDir);
                } else {
                    return None;
                }
            }
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Dir::ModuleDir(it) => it.syntax(),
            Dir::DomainDir(it) => it.syntax(),
            Dir::DomainsDir(it) => it.syntax(),
            Dir::DefineDir(it) => it.syntax(),
            Dir::LoadDir(it) => it.syntax(),
            Dir::AssertDir(it) => it.syntax(),
            Dir::AssertClosedDir(it) => it.syntax(),
            Dir::DeclareDir(it) => it.syntax(),
            Dir::ConstantDeclareDir(it) => it.syntax(),
            Dir::ExtendModuleDir(it) => it.syntax(),
            Dir::OpenDir(it) => it.syntax(),
            Dir::AssociativityDir(it) => it.syntax(),
            Dir::SetPrecedenceDir(it) => it.syntax(),
            Dir::OverloadDir(it) => it.syntax(),
            Dir::RuleDir(it) => it.syntax(),
        }
    }
}
impl From<IdentSortDecl> for SortDecl {
    fn from(node: IdentSortDecl) -> SortDecl {
        SortDecl::IdentSortDecl(node)
    }
}
impl From<CompoundSortDecl> for SortDecl {
    fn from(node: CompoundSortDecl) -> SortDecl {
        SortDecl::CompoundSortDecl(node)
    }
}
impl AstNode for SortDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, IDENT_SORT_DECL | COMPOUND_SORT_DECL)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_SORT_DECL => Self::IdentSortDecl(IdentSortDecl { syntax }),
            COMPOUND_SORT_DECL => Self::CompoundSortDecl(CompoundSortDecl { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            SortDecl::IdentSortDecl(it) => it.syntax(),
            SortDecl::CompoundSortDecl(it) => it.syntax(),
        }
    }
}
impl From<ConstantConstructor> for StructureConstructor {
    fn from(node: ConstantConstructor) -> StructureConstructor {
        StructureConstructor::ConstantConstructor(node)
    }
}
impl From<CompoundConstructor> for StructureConstructor {
    fn from(node: CompoundConstructor) -> StructureConstructor {
        StructureConstructor::CompoundConstructor(node)
    }
}
impl AstNode for StructureConstructor {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, CONSTANT_CONSTRUCTOR | COMPOUND_CONSTRUCTOR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            CONSTANT_CONSTRUCTOR => Self::ConstantConstructor(ConstantConstructor { syntax }),
            COMPOUND_CONSTRUCTOR => Self::CompoundConstructor(CompoundConstructor { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            StructureConstructor::ConstantConstructor(it) => it.syntax(),
            StructureConstructor::CompoundConstructor(it) => it.syntax(),
        }
    }
}
impl From<IdentSort> for LimitedSort {
    fn from(node: IdentSort) -> LimitedSort {
        LimitedSort::IdentSort(node)
    }
}
impl From<LimitedCompoundSort> for LimitedSort {
    fn from(node: LimitedCompoundSort) -> LimitedSort {
        LimitedSort::LimitedCompoundSort(node)
    }
}
impl AstNode for LimitedSort {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, IDENT_SORT | LIMITED_COMPOUND_SORT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_SORT => Self::IdentSort(IdentSort { syntax }),
            LIMITED_COMPOUND_SORT => Self::LimitedCompoundSort(LimitedCompoundSort { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            LimitedSort::IdentSort(it) => it.syntax(),
            LimitedSort::LimitedCompoundSort(it) => it.syntax(),
        }
    }
}
impl From<Definition> for MetaDefinition {
    fn from(node: Definition) -> MetaDefinition {
        MetaDefinition::Definition(node)
    }
}
impl From<Domain> for MetaDefinition {
    fn from(node: Domain) -> MetaDefinition {
        MetaDefinition::Domain(node)
    }
}
impl From<FunctionSymbol> for MetaDefinition {
    fn from(node: FunctionSymbol) -> MetaDefinition {
        MetaDefinition::FunctionSymbol(node)
    }
}
impl From<Assertion> for MetaDefinition {
    fn from(node: Assertion) -> MetaDefinition {
        MetaDefinition::Assertion(node)
    }
}
impl AstNode for MetaDefinition {
    fn can_cast(kind: SyntaxKind) -> bool {
        Definition::can_cast(kind)
            || Domain::can_cast(kind)
            || FunctionSymbol::can_cast(kind)
            || Assertion::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            other => {
                if false {
                    return None;
                } else if Definition::can_cast(other) {
                    return Definition::cast(syntax).map(Self::Definition);
                } else if Domain::can_cast(other) {
                    return Domain::cast(syntax).map(Self::Domain);
                } else if FunctionSymbol::can_cast(other) {
                    return FunctionSymbol::cast(syntax).map(Self::FunctionSymbol);
                } else if Assertion::can_cast(other) {
                    return Assertion::cast(syntax).map(Self::Assertion);
                } else {
                    return None;
                }
            }
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MetaDefinition::Definition(it) => it.syntax(),
            MetaDefinition::Domain(it) => it.syntax(),
            MetaDefinition::FunctionSymbol(it) => it.syntax(),
            MetaDefinition::Assertion(it) => it.syntax(),
        }
    }
}
impl From<InfixDefineDir> for Definition {
    fn from(node: InfixDefineDir) -> Definition {
        Definition::InfixDefineDir(node)
    }
}
impl From<PrefixDefineDir> for Definition {
    fn from(node: PrefixDefineDir) -> Definition {
        Definition::PrefixDefineDir(node)
    }
}
impl AstNode for Definition {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_DEFINE_DIR) || PrefixDefineDir::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_DEFINE_DIR => Self::InfixDefineDir(InfixDefineDir { syntax }),
            other => {
                if false {
                    return None;
                } else if PrefixDefineDir::can_cast(other) {
                    return PrefixDefineDir::cast(syntax).map(Self::PrefixDefineDir);
                } else {
                    return None;
                }
            }
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Definition::InfixDefineDir(it) => it.syntax(),
            Definition::PrefixDefineDir(it) => it.syntax(),
        }
    }
}
impl From<DomainDir> for Domain {
    fn from(node: DomainDir) -> Domain {
        Domain::DomainDir(node)
    }
}
impl From<DomainsDir> for Domain {
    fn from(node: DomainsDir) -> Domain {
        Domain::DomainsDir(node)
    }
}
impl AstNode for Domain {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, DOMAIN_DIR | DOMAINS_DIR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            DOMAIN_DIR => Self::DomainDir(DomainDir { syntax }),
            DOMAINS_DIR => Self::DomainsDir(DomainsDir { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Domain::DomainDir(it) => it.syntax(),
            Domain::DomainsDir(it) => it.syntax(),
        }
    }
}
impl From<DeclareDir> for FunctionSymbol {
    fn from(node: DeclareDir) -> FunctionSymbol {
        FunctionSymbol::DeclareDir(node)
    }
}
impl From<ConstantDeclareDir> for FunctionSymbol {
    fn from(node: ConstantDeclareDir) -> FunctionSymbol {
        FunctionSymbol::ConstantDeclareDir(node)
    }
}
impl AstNode for FunctionSymbol {
    fn can_cast(kind: SyntaxKind) -> bool {
        DeclareDir::can_cast(kind) || ConstantDeclareDir::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            other => {
                if false {
                    return None;
                } else if DeclareDir::can_cast(other) {
                    return DeclareDir::cast(syntax).map(Self::DeclareDir);
                } else if ConstantDeclareDir::can_cast(other) {
                    return ConstantDeclareDir::cast(syntax).map(Self::ConstantDeclareDir);
                } else {
                    return None;
                }
            }
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            FunctionSymbol::DeclareDir(it) => it.syntax(),
            FunctionSymbol::ConstantDeclareDir(it) => it.syntax(),
        }
    }
}
impl From<AssertDir> for Assertion {
    fn from(node: AssertDir) -> Assertion {
        Assertion::AssertDir(node)
    }
}
impl From<AssertClosedDir> for Assertion {
    fn from(node: AssertClosedDir) -> Assertion {
        Assertion::AssertClosedDir(node)
    }
}
impl AstNode for Assertion {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, ASSERT_CLOSED_DIR) || AssertDir::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ASSERT_CLOSED_DIR => Self::AssertClosedDir(AssertClosedDir { syntax }),
            other => {
                if false {
                    return None;
                } else if AssertDir::can_cast(other) {
                    return AssertDir::cast(syntax).map(Self::AssertDir);
                } else {
                    return None;
                }
            }
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Assertion::AssertDir(it) => it.syntax(),
            Assertion::AssertClosedDir(it) => it.syntax(),
        }
    }
}
impl From<PrefixDefine> for PrefixDefineDir {
    fn from(node: PrefixDefine) -> PrefixDefineDir {
        PrefixDefineDir::PrefixDefine(node)
    }
}
impl From<PrefixDefineBlocks> for PrefixDefineDir {
    fn from(node: PrefixDefineBlocks) -> PrefixDefineDir {
        PrefixDefineDir::PrefixDefineBlocks(node)
    }
}
impl AstNode for PrefixDefineDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, PREFIX_DEFINE | PREFIX_DEFINE_BLOCKS)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PREFIX_DEFINE => Self::PrefixDefine(PrefixDefine { syntax }),
            PREFIX_DEFINE_BLOCKS => Self::PrefixDefineBlocks(PrefixDefineBlocks { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            PrefixDefineDir::PrefixDefine(it) => it.syntax(),
            PrefixDefineDir::PrefixDefineBlocks(it) => it.syntax(),
        }
    }
}
impl From<StructureStmt> for Structure {
    fn from(node: StructureStmt) -> Structure {
        Structure::StructureStmt(node)
    }
}
impl From<StructuresStmt> for Structure {
    fn from(node: StructuresStmt) -> Structure {
        Structure::StructuresStmt(node)
    }
}
impl AstNode for Structure {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, STRUCTURE_STMT | STRUCTURES_STMT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            STRUCTURE_STMT => Self::StructureStmt(StructureStmt { syntax }),
            STRUCTURES_STMT => Self::StructuresStmt(StructuresStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Structure::StructureStmt(it) => it.syntax(),
            Structure::StructuresStmt(it) => it.syntax(),
        }
    }
}
impl From<DatatypeStmt> for Datatype {
    fn from(node: DatatypeStmt) -> Datatype {
        Datatype::DatatypeStmt(node)
    }
}
impl From<DatatypesStmt> for Datatype {
    fn from(node: DatatypesStmt) -> Datatype {
        Datatype::DatatypesStmt(node)
    }
}
impl AstNode for Datatype {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, DATATYPE_STMT | DATATYPES_STMT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            DATATYPE_STMT => Self::DatatypeStmt(DatatypeStmt { syntax }),
            DATATYPES_STMT => Self::DatatypesStmt(DatatypesStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Datatype::DatatypeStmt(it) => it.syntax(),
            Datatype::DatatypesStmt(it) => it.syntax(),
        }
    }
}
impl From<ModuleDir> for Module {
    fn from(node: ModuleDir) -> Module {
        Module::ModuleDir(node)
    }
}
impl From<ExtendModuleDir> for Module {
    fn from(node: ExtendModuleDir) -> Module {
        Module::ExtendModuleDir(node)
    }
}
impl AstNode for Module {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, MODULE_DIR | EXTEND_MODULE_DIR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            MODULE_DIR => Self::ModuleDir(ModuleDir { syntax }),
            EXTEND_MODULE_DIR => Self::ExtendModuleDir(ExtendModuleDir { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Module::ModuleDir(it) => it.syntax(),
            Module::ExtendModuleDir(it) => it.syntax(),
        }
    }
}
impl From<InfixAssertDir> for AssertDir {
    fn from(node: InfixAssertDir) -> AssertDir {
        AssertDir::InfixAssertDir(node)
    }
}
impl From<PrefixAssertDir> for AssertDir {
    fn from(node: PrefixAssertDir) -> AssertDir {
        AssertDir::PrefixAssertDir(node)
    }
}
impl AstNode for AssertDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_ASSERT_DIR | PREFIX_ASSERT_DIR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_ASSERT_DIR => Self::InfixAssertDir(InfixAssertDir { syntax }),
            PREFIX_ASSERT_DIR => Self::PrefixAssertDir(PrefixAssertDir { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AssertDir::InfixAssertDir(it) => it.syntax(),
            AssertDir::PrefixAssertDir(it) => it.syntax(),
        }
    }
}
impl From<PrefixDeclareDir> for DeclareDir {
    fn from(node: PrefixDeclareDir) -> DeclareDir {
        DeclareDir::PrefixDeclareDir(node)
    }
}
impl From<InfixDeclareDir> for DeclareDir {
    fn from(node: InfixDeclareDir) -> DeclareDir {
        DeclareDir::InfixDeclareDir(node)
    }
}
impl AstNode for DeclareDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, PREFIX_DECLARE_DIR | INFIX_DECLARE_DIR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PREFIX_DECLARE_DIR => Self::PrefixDeclareDir(PrefixDeclareDir { syntax }),
            INFIX_DECLARE_DIR => Self::InfixDeclareDir(InfixDeclareDir { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            DeclareDir::PrefixDeclareDir(it) => it.syntax(),
            DeclareDir::InfixDeclareDir(it) => it.syntax(),
        }
    }
}
impl From<InfixConstantDeclare> for ConstantDeclareDir {
    fn from(node: InfixConstantDeclare) -> ConstantDeclareDir {
        ConstantDeclareDir::InfixConstantDeclare(node)
    }
}
impl From<PrefixConstantDeclare> for ConstantDeclareDir {
    fn from(node: PrefixConstantDeclare) -> ConstantDeclareDir {
        ConstantDeclareDir::PrefixConstantDeclare(node)
    }
}
impl AstNode for ConstantDeclareDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_CONSTANT_DECLARE | PREFIX_CONSTANT_DECLARE)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_CONSTANT_DECLARE => Self::InfixConstantDeclare(InfixConstantDeclare { syntax }),
            PREFIX_CONSTANT_DECLARE => {
                Self::PrefixConstantDeclare(PrefixConstantDeclare { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ConstantDeclareDir::InfixConstantDeclare(it) => it.syntax(),
            ConstantDeclareDir::PrefixConstantDeclare(it) => it.syntax(),
        }
    }
}
impl From<InfixDefineDir> for DefineDir {
    fn from(node: InfixDefineDir) -> DefineDir {
        DefineDir::InfixDefineDir(node)
    }
}
impl From<PrefixDefineDir> for DefineDir {
    fn from(node: PrefixDefineDir) -> DefineDir {
        DefineDir::PrefixDefineDir(node)
    }
}
impl AstNode for DefineDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_DEFINE_DIR) || PrefixDefineDir::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_DEFINE_DIR => Self::InfixDefineDir(InfixDefineDir { syntax }),
            other => {
                if false {
                    return None;
                } else if PrefixDefineDir::can_cast(other) {
                    return PrefixDefineDir::cast(syntax).map(Self::PrefixDefineDir);
                } else {
                    return None;
                }
            }
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            DefineDir::InfixDefineDir(it) => it.syntax(),
            DefineDir::PrefixDefineDir(it) => it.syntax(),
        }
    }
}
impl From<OverloadSingle> for OverloadDir {
    fn from(node: OverloadSingle) -> OverloadDir {
        OverloadDir::OverloadSingle(node)
    }
}
impl From<OverloadMulti> for OverloadDir {
    fn from(node: OverloadMulti) -> OverloadDir {
        OverloadDir::OverloadMulti(node)
    }
}
impl AstNode for OverloadDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, OVERLOAD_SINGLE | OVERLOAD_MULTI)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            OVERLOAD_SINGLE => Self::OverloadSingle(OverloadSingle { syntax }),
            OVERLOAD_MULTI => Self::OverloadMulti(OverloadMulti { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            OverloadDir::OverloadSingle(it) => it.syntax(),
            OverloadDir::OverloadMulti(it) => it.syntax(),
        }
    }
}
impl From<InfixRuleDir> for RuleDir {
    fn from(node: InfixRuleDir) -> RuleDir {
        RuleDir::InfixRuleDir(node)
    }
}
impl From<PrefixRuleDir> for RuleDir {
    fn from(node: PrefixRuleDir) -> RuleDir {
        RuleDir::PrefixRuleDir(node)
    }
}
impl AstNode for RuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_RULE_DIR | PREFIX_RULE_DIR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_RULE_DIR => Self::InfixRuleDir(InfixRuleDir { syntax }),
            PREFIX_RULE_DIR => Self::PrefixRuleDir(PrefixRuleDir { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            RuleDir::InfixRuleDir(it) => it.syntax(),
            RuleDir::PrefixRuleDir(it) => it.syntax(),
        }
    }
}
impl From<PrefixSingleSymbol> for PrefixDeclareSymbols {
    fn from(node: PrefixSingleSymbol) -> PrefixDeclareSymbols {
        PrefixDeclareSymbols::PrefixSingleSymbol(node)
    }
}
impl From<PrefixMultiSymbols> for PrefixDeclareSymbols {
    fn from(node: PrefixMultiSymbols) -> PrefixDeclareSymbols {
        PrefixDeclareSymbols::PrefixMultiSymbols(node)
    }
}
impl AstNode for PrefixDeclareSymbols {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, PREFIX_SINGLE_SYMBOL | PREFIX_MULTI_SYMBOLS)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PREFIX_SINGLE_SYMBOL => Self::PrefixSingleSymbol(PrefixSingleSymbol { syntax }),
            PREFIX_MULTI_SYMBOLS => Self::PrefixMultiSymbols(PrefixMultiSymbols { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            PrefixDeclareSymbols::PrefixSingleSymbol(it) => it.syntax(),
            PrefixDeclareSymbols::PrefixMultiSymbols(it) => it.syntax(),
        }
    }
}
impl From<IdentExpr> for Expr {
    fn from(node: IdentExpr) -> Expr {
        Expr::IdentExpr(node)
    }
}
impl From<LiteralExpr> for Expr {
    fn from(node: LiteralExpr) -> Expr {
        Expr::LiteralExpr(node)
    }
}
impl From<UnitExpr> for Expr {
    fn from(node: UnitExpr) -> Expr {
        Expr::UnitExpr(node)
    }
}
impl From<TermVarExpr> for Expr {
    fn from(node: TermVarExpr) -> Expr {
        Expr::TermVarExpr(node)
    }
}
impl From<MetaIdent> for Expr {
    fn from(node: MetaIdent) -> Expr {
        Expr::MetaIdent(node)
    }
}
impl From<CheckExpr> for Expr {
    fn from(node: CheckExpr) -> Expr {
        Expr::CheckExpr(node)
    }
}
impl From<LambdaExpr> for Expr {
    fn from(node: LambdaExpr) -> Expr {
        Expr::LambdaExpr(node)
    }
}
impl From<ApplicationExpr> for Expr {
    fn from(node: ApplicationExpr) -> Expr {
        Expr::ApplicationExpr(node)
    }
}
impl From<ListExpr> for Expr {
    fn from(node: ListExpr) -> Expr {
        Expr::ListExpr(node)
    }
}
impl From<MethodExpr> for Expr {
    fn from(node: MethodExpr) -> Expr {
        Expr::MethodExpr(node)
    }
}
impl From<LetExpr> for Expr {
    fn from(node: LetExpr) -> Expr {
        Expr::LetExpr(node)
    }
}
impl From<LetRecExpr> for Expr {
    fn from(node: LetRecExpr) -> Expr {
        Expr::LetRecExpr(node)
    }
}
impl From<MatchExpr> for Expr {
    fn from(node: MatchExpr) -> Expr {
        Expr::MatchExpr(node)
    }
}
impl From<TryExpr> for Expr {
    fn from(node: TryExpr) -> Expr {
        Expr::TryExpr(node)
    }
}
impl From<CellExpr> for Expr {
    fn from(node: CellExpr) -> Expr {
        Expr::CellExpr(node)
    }
}
impl From<SetExpr> for Expr {
    fn from(node: SetExpr) -> Expr {
        Expr::SetExpr(node)
    }
}
impl From<RefExpr> for Expr {
    fn from(node: RefExpr) -> Expr {
        Expr::RefExpr(node)
    }
}
impl From<WhileExpr> for Expr {
    fn from(node: WhileExpr) -> Expr {
        Expr::WhileExpr(node)
    }
}
impl From<MakeVectorExpr> for Expr {
    fn from(node: MakeVectorExpr) -> Expr {
        Expr::MakeVectorExpr(node)
    }
}
impl From<VectorSubExpr> for Expr {
    fn from(node: VectorSubExpr) -> Expr {
        Expr::VectorSubExpr(node)
    }
}
impl From<VectorSetExpr> for Expr {
    fn from(node: VectorSetExpr) -> Expr {
        Expr::VectorSetExpr(node)
    }
}
impl From<SeqExpr> for Expr {
    fn from(node: SeqExpr) -> Expr {
        Expr::SeqExpr(node)
    }
}
impl From<AndExpr> for Expr {
    fn from(node: AndExpr) -> Expr {
        Expr::AndExpr(node)
    }
}
impl From<OrExpr> for Expr {
    fn from(node: OrExpr) -> Expr {
        Expr::OrExpr(node)
    }
}
impl From<MapExpr> for Expr {
    fn from(node: MapExpr) -> Expr {
        Expr::MapExpr(node)
    }
}
impl From<WildcardExpr> for Expr {
    fn from(node: WildcardExpr) -> Expr {
        Expr::WildcardExpr(node)
    }
}
impl From<PrefixCheckExpr> for Expr {
    fn from(node: PrefixCheckExpr) -> Expr {
        Expr::PrefixCheckExpr(node)
    }
}
impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            IDENT_EXPR
                | LITERAL_EXPR
                | UNIT_EXPR
                | TERM_VAR_EXPR
                | META_IDENT
                | CHECK_EXPR
                | LAMBDA_EXPR
                | APPLICATION_EXPR
                | LIST_EXPR
                | METHOD_EXPR
                | LET_EXPR
                | LET_REC_EXPR
                | TRY_EXPR
                | CELL_EXPR
                | SET_EXPR
                | REF_EXPR
                | WHILE_EXPR
                | MAKE_VECTOR_EXPR
                | VECTOR_SUB_EXPR
                | VECTOR_SET_EXPR
                | SEQ_EXPR
                | AND_EXPR
                | OR_EXPR
                | MAP_EXPR
                | WILDCARD_EXPR
                | PREFIX_CHECK_EXPR
        ) || MatchExpr::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_EXPR => Self::IdentExpr(IdentExpr { syntax }),
            LITERAL_EXPR => Self::LiteralExpr(LiteralExpr { syntax }),
            UNIT_EXPR => Self::UnitExpr(UnitExpr { syntax }),
            TERM_VAR_EXPR => Self::TermVarExpr(TermVarExpr { syntax }),
            META_IDENT => Self::MetaIdent(MetaIdent { syntax }),
            CHECK_EXPR => Self::CheckExpr(CheckExpr { syntax }),
            LAMBDA_EXPR => Self::LambdaExpr(LambdaExpr { syntax }),
            APPLICATION_EXPR => Self::ApplicationExpr(ApplicationExpr { syntax }),
            LIST_EXPR => Self::ListExpr(ListExpr { syntax }),
            METHOD_EXPR => Self::MethodExpr(MethodExpr { syntax }),
            LET_EXPR => Self::LetExpr(LetExpr { syntax }),
            LET_REC_EXPR => Self::LetRecExpr(LetRecExpr { syntax }),
            TRY_EXPR => Self::TryExpr(TryExpr { syntax }),
            CELL_EXPR => Self::CellExpr(CellExpr { syntax }),
            SET_EXPR => Self::SetExpr(SetExpr { syntax }),
            REF_EXPR => Self::RefExpr(RefExpr { syntax }),
            WHILE_EXPR => Self::WhileExpr(WhileExpr { syntax }),
            MAKE_VECTOR_EXPR => Self::MakeVectorExpr(MakeVectorExpr { syntax }),
            VECTOR_SUB_EXPR => Self::VectorSubExpr(VectorSubExpr { syntax }),
            VECTOR_SET_EXPR => Self::VectorSetExpr(VectorSetExpr { syntax }),
            SEQ_EXPR => Self::SeqExpr(SeqExpr { syntax }),
            AND_EXPR => Self::AndExpr(AndExpr { syntax }),
            OR_EXPR => Self::OrExpr(OrExpr { syntax }),
            MAP_EXPR => Self::MapExpr(MapExpr { syntax }),
            WILDCARD_EXPR => Self::WildcardExpr(WildcardExpr { syntax }),
            PREFIX_CHECK_EXPR => Self::PrefixCheckExpr(PrefixCheckExpr { syntax }),
            other => {
                if false {
                    return None;
                } else if MatchExpr::can_cast(other) {
                    return MatchExpr::cast(syntax).map(Self::MatchExpr);
                } else {
                    return None;
                }
            }
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::IdentExpr(it) => it.syntax(),
            Expr::LiteralExpr(it) => it.syntax(),
            Expr::UnitExpr(it) => it.syntax(),
            Expr::TermVarExpr(it) => it.syntax(),
            Expr::MetaIdent(it) => it.syntax(),
            Expr::CheckExpr(it) => it.syntax(),
            Expr::LambdaExpr(it) => it.syntax(),
            Expr::ApplicationExpr(it) => it.syntax(),
            Expr::ListExpr(it) => it.syntax(),
            Expr::MethodExpr(it) => it.syntax(),
            Expr::LetExpr(it) => it.syntax(),
            Expr::LetRecExpr(it) => it.syntax(),
            Expr::MatchExpr(it) => it.syntax(),
            Expr::TryExpr(it) => it.syntax(),
            Expr::CellExpr(it) => it.syntax(),
            Expr::SetExpr(it) => it.syntax(),
            Expr::RefExpr(it) => it.syntax(),
            Expr::WhileExpr(it) => it.syntax(),
            Expr::MakeVectorExpr(it) => it.syntax(),
            Expr::VectorSubExpr(it) => it.syntax(),
            Expr::VectorSetExpr(it) => it.syntax(),
            Expr::SeqExpr(it) => it.syntax(),
            Expr::AndExpr(it) => it.syntax(),
            Expr::OrExpr(it) => it.syntax(),
            Expr::MapExpr(it) => it.syntax(),
            Expr::WildcardExpr(it) => it.syntax(),
            Expr::PrefixCheckExpr(it) => it.syntax(),
        }
    }
}
impl From<Name> for DefineName {
    fn from(node: Name) -> DefineName {
        DefineName::Name(node)
    }
}
impl From<DefineNamedPattern> for DefineName {
    fn from(node: DefineNamedPattern) -> DefineName {
        DefineName::DefineNamedPattern(node)
    }
}
impl From<DefineProc> for DefineName {
    fn from(node: DefineProc) -> DefineName {
        DefineName::DefineProc(node)
    }
}
impl From<ListPat> for DefineName {
    fn from(node: ListPat) -> DefineName {
        DefineName::ListPat(node)
    }
}
impl AstNode for DefineName {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, NAME | DEFINE_NAMED_PATTERN | DEFINE_PROC | LIST_PAT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAME => Self::Name(Name { syntax }),
            DEFINE_NAMED_PATTERN => Self::DefineNamedPattern(DefineNamedPattern { syntax }),
            DEFINE_PROC => Self::DefineProc(DefineProc { syntax }),
            LIST_PAT => Self::ListPat(ListPat { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            DefineName::Name(it) => it.syntax(),
            DefineName::DefineNamedPattern(it) => it.syntax(),
            DefineName::DefineProc(it) => it.syntax(),
            DefineName::ListPat(it) => it.syntax(),
        }
    }
}
impl From<MethodCallDed> for Ded {
    fn from(node: MethodCallDed) -> Ded {
        Ded::MethodCallDed(node)
    }
}
impl From<BangMethodCallDed> for Ded {
    fn from(node: BangMethodCallDed) -> Ded {
        Ded::BangMethodCallDed(node)
    }
}
impl From<AssumeDed> for Ded {
    fn from(node: AssumeDed) -> Ded {
        Ded::AssumeDed(node)
    }
}
impl From<NamedAssumeDed> for Ded {
    fn from(node: NamedAssumeDed) -> Ded {
        Ded::NamedAssumeDed(node)
    }
}
impl From<ProofByContraDed> for Ded {
    fn from(node: ProofByContraDed) -> Ded {
        Ded::ProofByContraDed(node)
    }
}
impl From<GeneralizeOverDed> for Ded {
    fn from(node: GeneralizeOverDed) -> Ded {
        Ded::GeneralizeOverDed(node)
    }
}
impl From<PickAnyDed> for Ded {
    fn from(node: PickAnyDed) -> Ded {
        Ded::PickAnyDed(node)
    }
}
impl From<WithWitnessDed> for Ded {
    fn from(node: WithWitnessDed) -> Ded {
        Ded::WithWitnessDed(node)
    }
}
impl From<PickWitnessDed> for Ded {
    fn from(node: PickWitnessDed) -> Ded {
        Ded::PickWitnessDed(node)
    }
}
impl From<PickWitnessesDed> for Ded {
    fn from(node: PickWitnessesDed) -> Ded {
        Ded::PickWitnessesDed(node)
    }
}
impl From<InductDed> for Ded {
    fn from(node: InductDed) -> Ded {
        Ded::InductDed(node)
    }
}
impl From<CasesDed> for Ded {
    fn from(node: CasesDed) -> Ded {
        Ded::CasesDed(node)
    }
}
impl From<CheckDed> for Ded {
    fn from(node: CheckDed) -> Ded {
        Ded::CheckDed(node)
    }
}
impl From<MatchDed> for Ded {
    fn from(node: MatchDed) -> Ded {
        Ded::MatchDed(node)
    }
}
impl From<LetDed> for Ded {
    fn from(node: LetDed) -> Ded {
        Ded::LetDed(node)
    }
}
impl From<LetRecDed> for Ded {
    fn from(node: LetRecDed) -> Ded {
        Ded::LetRecDed(node)
    }
}
impl From<TryDed> for Ded {
    fn from(node: TryDed) -> Ded {
        Ded::TryDed(node)
    }
}
impl From<ConcludeDed> for Ded {
    fn from(node: ConcludeDed) -> Ded {
        Ded::ConcludeDed(node)
    }
}
impl From<InferBlockDed> for Ded {
    fn from(node: InferBlockDed) -> Ded {
        Ded::InferBlockDed(node)
    }
}
impl From<PrefixAssumeDed> for Ded {
    fn from(node: PrefixAssumeDed) -> Ded {
        Ded::PrefixAssumeDed(node)
    }
}
impl From<SeqDed> for Ded {
    fn from(node: SeqDed) -> Ded {
        Ded::SeqDed(node)
    }
}
impl AstNode for Ded {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            METHOD_CALL_DED
                | BANG_METHOD_CALL_DED
                | ASSUME_DED
                | NAMED_ASSUME_DED
                | PROOF_BY_CONTRA_DED
                | GENERALIZE_OVER_DED
                | PICK_ANY_DED
                | WITH_WITNESS_DED
                | PICK_WITNESS_DED
                | PICK_WITNESSES_DED
                | INDUCT_DED
                | CASES_DED
                | CONCLUDE_DED
                | INFER_BLOCK_DED
                | SEQ_DED
        ) || CheckDed::can_cast(kind)
            || MatchDed::can_cast(kind)
            || LetDed::can_cast(kind)
            || LetRecDed::can_cast(kind)
            || TryDed::can_cast(kind)
            || PrefixAssumeDed::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            METHOD_CALL_DED => Self::MethodCallDed(MethodCallDed { syntax }),
            BANG_METHOD_CALL_DED => Self::BangMethodCallDed(BangMethodCallDed { syntax }),
            ASSUME_DED => Self::AssumeDed(AssumeDed { syntax }),
            NAMED_ASSUME_DED => Self::NamedAssumeDed(NamedAssumeDed { syntax }),
            PROOF_BY_CONTRA_DED => Self::ProofByContraDed(ProofByContraDed { syntax }),
            GENERALIZE_OVER_DED => Self::GeneralizeOverDed(GeneralizeOverDed { syntax }),
            PICK_ANY_DED => Self::PickAnyDed(PickAnyDed { syntax }),
            WITH_WITNESS_DED => Self::WithWitnessDed(WithWitnessDed { syntax }),
            PICK_WITNESS_DED => Self::PickWitnessDed(PickWitnessDed { syntax }),
            PICK_WITNESSES_DED => Self::PickWitnessesDed(PickWitnessesDed { syntax }),
            INDUCT_DED => Self::InductDed(InductDed { syntax }),
            CASES_DED => Self::CasesDed(CasesDed { syntax }),
            CONCLUDE_DED => Self::ConcludeDed(ConcludeDed { syntax }),
            INFER_BLOCK_DED => Self::InferBlockDed(InferBlockDed { syntax }),
            SEQ_DED => Self::SeqDed(SeqDed { syntax }),
            other => {
                if false {
                    return None;
                } else if CheckDed::can_cast(other) {
                    return CheckDed::cast(syntax).map(Self::CheckDed);
                } else if MatchDed::can_cast(other) {
                    return MatchDed::cast(syntax).map(Self::MatchDed);
                } else if LetDed::can_cast(other) {
                    return LetDed::cast(syntax).map(Self::LetDed);
                } else if LetRecDed::can_cast(other) {
                    return LetRecDed::cast(syntax).map(Self::LetRecDed);
                } else if TryDed::can_cast(other) {
                    return TryDed::cast(syntax).map(Self::TryDed);
                } else if PrefixAssumeDed::can_cast(other) {
                    return PrefixAssumeDed::cast(syntax).map(Self::PrefixAssumeDed);
                } else {
                    return None;
                }
            }
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Ded::MethodCallDed(it) => it.syntax(),
            Ded::BangMethodCallDed(it) => it.syntax(),
            Ded::AssumeDed(it) => it.syntax(),
            Ded::NamedAssumeDed(it) => it.syntax(),
            Ded::ProofByContraDed(it) => it.syntax(),
            Ded::GeneralizeOverDed(it) => it.syntax(),
            Ded::PickAnyDed(it) => it.syntax(),
            Ded::WithWitnessDed(it) => it.syntax(),
            Ded::PickWitnessDed(it) => it.syntax(),
            Ded::PickWitnessesDed(it) => it.syntax(),
            Ded::InductDed(it) => it.syntax(),
            Ded::CasesDed(it) => it.syntax(),
            Ded::CheckDed(it) => it.syntax(),
            Ded::MatchDed(it) => it.syntax(),
            Ded::LetDed(it) => it.syntax(),
            Ded::LetRecDed(it) => it.syntax(),
            Ded::TryDed(it) => it.syntax(),
            Ded::ConcludeDed(it) => it.syntax(),
            Ded::InferBlockDed(it) => it.syntax(),
            Ded::PrefixAssumeDed(it) => it.syntax(),
            Ded::SeqDed(it) => it.syntax(),
        }
    }
}
impl From<InfixMatchExpr> for MatchExpr {
    fn from(node: InfixMatchExpr) -> MatchExpr {
        MatchExpr::InfixMatchExpr(node)
    }
}
impl From<PrefixMatchExpr> for MatchExpr {
    fn from(node: PrefixMatchExpr) -> MatchExpr {
        MatchExpr::PrefixMatchExpr(node)
    }
}
impl AstNode for MatchExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_MATCH_EXPR | PREFIX_MATCH_EXPR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_MATCH_EXPR => Self::InfixMatchExpr(InfixMatchExpr { syntax }),
            PREFIX_MATCH_EXPR => Self::PrefixMatchExpr(PrefixMatchExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MatchExpr::InfixMatchExpr(it) => it.syntax(),
            MatchExpr::PrefixMatchExpr(it) => it.syntax(),
        }
    }
}
impl From<InfixCheckDed> for CheckDed {
    fn from(node: InfixCheckDed) -> CheckDed {
        CheckDed::InfixCheckDed(node)
    }
}
impl From<PrefixCheckDed> for CheckDed {
    fn from(node: PrefixCheckDed) -> CheckDed {
        CheckDed::PrefixCheckDed(node)
    }
}
impl AstNode for CheckDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_CHECK_DED | PREFIX_CHECK_DED)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_CHECK_DED => Self::InfixCheckDed(InfixCheckDed { syntax }),
            PREFIX_CHECK_DED => Self::PrefixCheckDed(PrefixCheckDed { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            CheckDed::InfixCheckDed(it) => it.syntax(),
            CheckDed::PrefixCheckDed(it) => it.syntax(),
        }
    }
}
impl From<InfixMatchDed> for MatchDed {
    fn from(node: InfixMatchDed) -> MatchDed {
        MatchDed::InfixMatchDed(node)
    }
}
impl From<PrefixMatchDed> for MatchDed {
    fn from(node: PrefixMatchDed) -> MatchDed {
        MatchDed::PrefixMatchDed(node)
    }
}
impl AstNode for MatchDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_MATCH_DED | PREFIX_MATCH_DED)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_MATCH_DED => Self::InfixMatchDed(InfixMatchDed { syntax }),
            PREFIX_MATCH_DED => Self::PrefixMatchDed(PrefixMatchDed { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MatchDed::InfixMatchDed(it) => it.syntax(),
            MatchDed::PrefixMatchDed(it) => it.syntax(),
        }
    }
}
impl From<InfixLetDed> for LetDed {
    fn from(node: InfixLetDed) -> LetDed {
        LetDed::InfixLetDed(node)
    }
}
impl From<PrefixLetDed> for LetDed {
    fn from(node: PrefixLetDed) -> LetDed {
        LetDed::PrefixLetDed(node)
    }
}
impl AstNode for LetDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_LET_DED | PREFIX_LET_DED)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_LET_DED => Self::InfixLetDed(InfixLetDed { syntax }),
            PREFIX_LET_DED => Self::PrefixLetDed(PrefixLetDed { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            LetDed::InfixLetDed(it) => it.syntax(),
            LetDed::PrefixLetDed(it) => it.syntax(),
        }
    }
}
impl From<InfixLetRecDed> for LetRecDed {
    fn from(node: InfixLetRecDed) -> LetRecDed {
        LetRecDed::InfixLetRecDed(node)
    }
}
impl From<PrefixLetRecDed> for LetRecDed {
    fn from(node: PrefixLetRecDed) -> LetRecDed {
        LetRecDed::PrefixLetRecDed(node)
    }
}
impl AstNode for LetRecDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_LET_REC_DED | PREFIX_LET_REC_DED)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_LET_REC_DED => Self::InfixLetRecDed(InfixLetRecDed { syntax }),
            PREFIX_LET_REC_DED => Self::PrefixLetRecDed(PrefixLetRecDed { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            LetRecDed::InfixLetRecDed(it) => it.syntax(),
            LetRecDed::PrefixLetRecDed(it) => it.syntax(),
        }
    }
}
impl From<InfixTryDed> for TryDed {
    fn from(node: InfixTryDed) -> TryDed {
        TryDed::InfixTryDed(node)
    }
}
impl From<PrefixTryDed> for TryDed {
    fn from(node: PrefixTryDed) -> TryDed {
        TryDed::PrefixTryDed(node)
    }
}
impl AstNode for TryDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_TRY_DED | PREFIX_TRY_DED)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_TRY_DED => Self::InfixTryDed(InfixTryDed { syntax }),
            PREFIX_TRY_DED => Self::PrefixTryDed(PrefixTryDed { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TryDed::InfixTryDed(it) => it.syntax(),
            TryDed::PrefixTryDed(it) => it.syntax(),
        }
    }
}
impl From<PrefixNamedAssumeDed> for PrefixAssumeDed {
    fn from(node: PrefixNamedAssumeDed) -> PrefixAssumeDed {
        PrefixAssumeDed::PrefixNamedAssumeDed(node)
    }
}
impl From<PrefixSingleAssumeDed> for PrefixAssumeDed {
    fn from(node: PrefixSingleAssumeDed) -> PrefixAssumeDed {
        PrefixAssumeDed::PrefixSingleAssumeDed(node)
    }
}
impl From<PrefixAssumeLetDed> for PrefixAssumeDed {
    fn from(node: PrefixAssumeLetDed) -> PrefixAssumeDed {
        PrefixAssumeDed::PrefixAssumeLetDed(node)
    }
}
impl AstNode for PrefixAssumeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            PREFIX_NAMED_ASSUME_DED | PREFIX_SINGLE_ASSUME_DED | PREFIX_ASSUME_LET_DED
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PREFIX_NAMED_ASSUME_DED => Self::PrefixNamedAssumeDed(PrefixNamedAssumeDed { syntax }),
            PREFIX_SINGLE_ASSUME_DED => {
                Self::PrefixSingleAssumeDed(PrefixSingleAssumeDed { syntax })
            }
            PREFIX_ASSUME_LET_DED => Self::PrefixAssumeLetDed(PrefixAssumeLetDed { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            PrefixAssumeDed::PrefixNamedAssumeDed(it) => it.syntax(),
            PrefixAssumeDed::PrefixSingleAssumeDed(it) => it.syntax(),
            PrefixAssumeDed::PrefixAssumeLetDed(it) => it.syntax(),
        }
    }
}
impl From<Inference> for InferOrExpr {
    fn from(node: Inference) -> InferOrExpr {
        InferOrExpr::Inference(node)
    }
}
impl From<Expr> for InferOrExpr {
    fn from(node: Expr) -> InferOrExpr {
        InferOrExpr::Expr(node)
    }
}
impl AstNode for InferOrExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        Inference::can_cast(kind) || Expr::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            other => {
                if false {
                    return None;
                } else if Inference::can_cast(other) {
                    return Inference::cast(syntax).map(Self::Inference);
                } else if Expr::can_cast(other) {
                    return Expr::cast(syntax).map(Self::Expr);
                } else {
                    return None;
                }
            }
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            InferOrExpr::Inference(it) => it.syntax(),
            InferOrExpr::Expr(it) => it.syntax(),
        }
    }
}
impl From<InferFrom> for Inference {
    fn from(node: InferFrom) -> Inference {
        Inference::InferFrom(node)
    }
}
impl From<InferBy> for Inference {
    fn from(node: InferBy) -> Inference {
        Inference::InferBy(node)
    }
}
impl From<Ded> for Inference {
    fn from(node: Ded) -> Inference {
        Inference::Ded(node)
    }
}
impl AstNode for Inference {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFER_FROM | INFER_BY) || Ded::can_cast(kind)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFER_FROM => Self::InferFrom(InferFrom { syntax }),
            INFER_BY => Self::InferBy(InferBy { syntax }),
            other => {
                if false {
                    return None;
                } else if Ded::can_cast(other) {
                    return Ded::cast(syntax).map(Self::Ded);
                } else {
                    return None;
                }
            }
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Inference::InferFrom(it) => it.syntax(),
            Inference::InferBy(it) => it.syntax(),
            Inference::Ded(it) => it.syntax(),
        }
    }
}
impl AnyHasDefineBody {
    #[inline]
    pub fn new<T: ast::HasDefineBody>(node: T) -> AnyHasDefineBody {
        AnyHasDefineBody {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasDefineBody {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_DEFINE_DIR | PREFIX_DEFINE | PREFIX_DEFINE_BLOCK)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasDefineBody { syntax })
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AnyHasDefineName {
    #[inline]
    pub fn new<T: ast::HasDefineName>(node: T) -> AnyHasDefineName {
        AnyHasDefineName {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasDefineName {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_DEFINE_DIR | PREFIX_DEFINE)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasDefineName { syntax })
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AnyHasName {
    #[inline]
    pub fn new<T: ast::HasName>(node: T) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasName {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            TYPED_PARAM
                | OP_ANNOTATED_PARAM
                | CONSTANT_CONSTRUCTOR
                | COMPOUND_CONSTRUCTOR
                | MODULE_DIR
                | EXTEND_MODULE_DIR
                | ASSERT_CLOSED_DIR
                | IDENT_SORT_DECL
                | PREFIX_SINGLE_SYMBOL
                | DECLARE_ATTR
                | DEFINE_NAMED_PATTERN
                | DEFINE_PROC
                | INFIX_ASSERT_DIR
                | PREFIX_ASSERT_DIR
                | INFIX_RULE_DIR
                | PREFIX_RULE_DIR
                | DEFINE_SORT_DIR
                | LET_REC_PART
                | PICK_WITNESS_DED
                | PICK_WITNESSES_DED
                | CONCLUDE_DED
                | ASSUME_PART
                | PREFIX_NAMED_ASSUME_DED
                | MAYBE_WILDCARD_OP_ANNOTATED_PARAM
                | NAMED_PAT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasName { syntax })
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AnyHasNameRef {
    #[inline]
    pub fn new<T: ast::HasNameRef>(node: T) -> AnyHasNameRef {
        AnyHasNameRef {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasNameRef {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            OP_ANNOTATED_PARAM | IDENT_SORT | ASSOCIATIVITY_DIR | IDENT_EXPR | VAL_OF_PAT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasNameRef { syntax })
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Display for MaybeTypedParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Sort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MaybeWildcardTypedParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Pat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Phrase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Dir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SortDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructureConstructor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LimitedSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MetaDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Definition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Domain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctionSymbol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Assertion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDefineDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Structure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Datatype {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssertDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DeclareDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConstantDeclareDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OverloadDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDeclareSymbols {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Ded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetRecDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixAssumeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InferOrExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Inference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NameRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MetaIdent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Unit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypedParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OpAnnotatedParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Wildcard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VarSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompoundSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DatatypeStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructureStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DatatypesStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructuresStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructureNameDef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConstantConstructor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompoundConstructor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LimitedCompoundSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MaybeTaggedFieldSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructureDef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixDefineDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExtendModuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssertClosedDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DomainDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DomainsDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LoadDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OpenDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssociativityDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SetPrecedenceDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentSortDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompoundSortDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixConstantDeclare {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixConstantDeclare {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDeclareDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixSortVarsDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDeclareAttrs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixSingleSymbol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixMultiSymbols {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DeclareAttr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InputTransformDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixDeclareDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SortVarsDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FuncSorts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DeclareAttrs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDefine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDefineBlocks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDefineBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineNamedPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineProc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixAssertDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixAssertDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixRuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixRuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExpandInputDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineSortDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PhrasePair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OverloadSingle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OverloadMulti {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LiteralExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnitExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TermVarExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LambdaExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ApplicationExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MethodExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetRecExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CellExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RefExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhileExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MakeVectorExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VectorSubExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VectorSetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SeqExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AndExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OrExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MapExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WildcardExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixCheckExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MetaIdentExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixLetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixLetRecExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetRecPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixMatchExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixMatchExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixTryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MapBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MethodCallDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BangMethodCallDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssumeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedAssumeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ProofByContraDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GeneralizeOverDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PickAnyDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WithWitnessDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PickWitnessDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PickWitnessesDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InductDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CasesDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConcludeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InferBlockDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SeqDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssumePart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixNamedAssumeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixSingleAssumeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixAssumeLetDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RestrictedMatchDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckDedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixCheckDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixCheckDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckDedArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixMatchDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixMatchDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchDedArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchDedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixLetDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixLetRecDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixLetDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixLetRecDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixTryDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixTryDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryDedArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MaybeNamedInference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MaybeWildcardOpAnnotatedParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InferFrom {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InferBy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ByDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VarPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MetaIdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LiteralPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnitPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ValOfPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListOfPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SplitPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompoundPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WherePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SomeThingPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OrPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SomeThing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
